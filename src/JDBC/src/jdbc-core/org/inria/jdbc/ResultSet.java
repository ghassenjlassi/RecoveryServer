
package org.inria.jdbc;

/**
 * <P>A ResultSet provides access to a table of data generated by
 * executing a Statement. The table rows are retrieved in
 * sequence. Within a row its column values can be accessed in any
 * order.
 *
 * <P>A ResultSet maintains a cursor pointing to its current row of
 * data.  Initially the cursor is positioned before the first row.
 * The 'next' method moves the cursor to the next row.
 *
 * <P>The getXXX methods retrieve column values for the current
 * row.  You can retrieve values either using the index number of the
 * column, or by using the name of the column.  In general using the
 * column index will be more efficient.  Columns are numbered from 1.
 *
 * <P>For maximum portability, ResultSet columns within each row should be
 * read in left-to-right order and each column should be read only once.
 *
 * <P>For the getXXX methods, the JDBC driver attempts to convert the
 * underlying data to the specified Java type and returns a suitable
 * Java value.  See the JDBC specification for allowable mappings
 * from SQL types to Java types with the ResultSet.getXXX methods.
 *
 * <P>Column names used as input to getXXX methods are case
 * insensitive.  When performing a getXXX using a column name, if
 * several columns have the same name, then the value of the first
 * matching column will be returned. The column name option is
 * designed to be used when column names are used in the SQL
 * query. For columns that are NOT explicitly named in the query, it
 * is best to use column numbers. If column names were used there is
 * no way for the programmer to guarantee that they actually refer to
 * the intended columns.
 *
 * <P>A ResultSet is automatically closed by the Statement that
 * generated it when that Statement is closed, re-executed, or is used
 * to retrieve the next result from a sequence of multiple results.
 *
 * <P>The number, types and properties of a ResultSet's columns are
 * provided by the ResulSetMetaData object returned by the getMetaData
 * method.
 *
 * @see Statement#executeQuery
 * @see Statement#getResultSet
 * @see ResultSetMetaData
 */

/*=============================================================================

Name: ResultSet.java

Abs:  Implements the interface java.sql.ResultSet

Auth: 18-09-2007, Kevin JACQUEMIN (KJ):
Rev:  10-11-2007, Kevin JACQUEMIN (KJ):

=============================================================================*/

import java.sql.Blob;
import java.sql.Date;
import java.sql.SQLException;
import java.util.Calendar;

import org.inria.jdbc.Blob.BlobId;

public class ResultSet implements java.sql.ResultSet
{
	private DBMS client;
	private boolean wasNull;
	private ResultSetMetaData metadata;
	private byte[][] row; // storage for the results
	private int numberOfTuplesCachedForCMD_NEXT;
	private int offsetInCacheForCMD_NEXT;
	private byte[] bufferForCMD_NEXT;
	private boolean hasMoreTuples;

	public		static final byte T_SIZEINT			= Integer.SIZE / 8;
	public		static final byte T_SIZESHORT		= Short.SIZE / 8;

	/**
	 * Constructs a ResultSet from a metadata description provided by an EP.
	 *
	 * @param ep_full
	 * @param client
	 * @throws SQLException
	 */
	ResultSet( int ep_full, DBMS cl ) throws SQLException
	{
		metadata = ResultSetMetaData.build( ep_full );
		cl.call( Macro.CMD_QUERYMD, null,
				 metadata.meta_to_send, metadata.meta_to_send.length, null );
		row = new byte[ metadata.nb_cols ][];
		client = cl;
		numberOfTuplesCachedForCMD_NEXT = 0;
		hasMoreTuples = true;
	}

	/////////////////////////////////////////////
	/////////////////////////////////////////////
	//
	//		Connection Management
	//
	/////////////////////////////////////////////
	/////////////////////////////////////////////

	@Override
	public void close() throws SQLException
	{
		client.close();
	}

	/////////////////////////////////////////////
	/////////////////////////////////////////////
	//
	//		METADATA
	//
	/////////////////////////////////////////////
	/////////////////////////////////////////////

	@Override
	public int findColumn( String s ) throws SQLException
	{
		for ( int i = 0, nb_cols = metadata.nb_cols; i < nb_cols; ++i )
		{
			if ( metadata.col_names[ i ].equals( s ) )
				return i + 1;
		}
		throw new SQLException( "Unknown column name: " + s );
	}

	@Override
	public java.sql.ResultSetMetaData getMetaData() throws SQLException
	{
		return metadata;
	}

	/////////////////////////////////////////////
	/////////////////////////////////////////////
	//
	//		MOVEMENTS IN THE RESULTSET
	//
	/////////////////////////////////////////////
	/////////////////////////////////////////////

	@Override
	public boolean next() throws SQLException
	{
		byte[] col_size = new byte[2];
		int size_data;
		
		if( numberOfTuplesCachedForCMD_NEXT == 0 )
		{
			if ( !hasMoreTuples )
			{
				hasMoreTuples = true;
				return false;
			}
			int status = client.sendData( new byte[] { Macro.STATE_DBMS, Macro.CMD_NEXT, 0 });
			if ( status != 0 )
				throw new SQLException( "Expected 0, received " + status + "." );
	
			byte[] res = new byte[ T_SIZESHORT ];
			client.receiveData( res );
			short packet_size = DBMSFactory.bytea2short( res );
	
			if ( packet_size == 0 )
			{
				hasMoreTuples = true;
				return false;
			}
			
			bufferForCMD_NEXT = new byte[ packet_size ];
			client.receiveData( bufferForCMD_NEXT );
			
			numberOfTuplesCachedForCMD_NEXT = DBMSFactory.bytea2short( bufferForCMD_NEXT );
			hasMoreTuples = (bufferForCMD_NEXT[ 2 ] == 1);
			offsetInCacheForCMD_NEXT = 3;
		}	

		col_size[0] = bufferForCMD_NEXT[ offsetInCacheForCMD_NEXT++ ];
		col_size[1] = bufferForCMD_NEXT[ offsetInCacheForCMD_NEXT++ ];
		size_data = DBMSFactory.bytea2short( col_size );
			
		int i = 0;
		while ( size_data != 0 )
		{
			row[ i ] = new byte[ size_data ];
			System.arraycopy(bufferForCMD_NEXT, offsetInCacheForCMD_NEXT, row[ i++ ], 0, size_data);
			offsetInCacheForCMD_NEXT += size_data;

			col_size[0] = bufferForCMD_NEXT[ offsetInCacheForCMD_NEXT++ ];
			col_size[1] = bufferForCMD_NEXT[ offsetInCacheForCMD_NEXT++ ];
			size_data = DBMSFactory.bytea2short( col_size );
		}

		numberOfTuplesCachedForCMD_NEXT--;
		return true;
	}

	@Override
	public boolean relative( int m ) throws SQLException
	{
		if ( m < 0 )
			throw new SQLException("Negative relative movements not supported");
		for ( int i = 0; i < m; ++i )
		{
			if ( !next() )
				return false;
		}
		return true;
	}

	/////////////////////////////////////////////
	/////////////////////////////////////////////
	//
	//		GETXXX METHODS
	//
	/////////////////////////////////////////////
	/////////////////////////////////////////////

	@Override
	public boolean wasNull() throws SQLException
	{
		return wasNull;
	}

	@Override
	public Date getDate( int index ) throws SQLException
	{
		int row_index = index - 1;
		if ( row[row_index] == null )
		{
			wasNull = true;
			return null;
		}
		int year =  ( (row[ row_index ][ 2 ] + 256) % 256 ) |
					(((row[ row_index ][ 3 ] + 256) % 256) << 8 );
		if ( year == 0 )
		{
			wasNull = true;
			return null;
		}
		wasNull = false;
		java.util.Calendar cal = java.util.Calendar.getInstance();
		cal.set( Calendar.YEAR  , year );
		cal.set( Calendar.MONTH , row[ row_index ][ 1 ] - 1 );
		cal.set( Calendar.DATE  , row[ row_index ][ 0 ] );
		cal.set( Calendar.HOUR  , 0 );
		cal.set( Calendar.MINUTE, 0 );
		return new java.sql.Date( cal.getTime().getTime() );
	}

	/**
	 * FIXME: Ugly proprietary hack to prevent usage of costly Calendar and Date
	 * instances. Remove that! It's too ugly :-(
	 * Used in DBMS/src/com/gemalto/dmsp/DBUtil.java
	 */
	public String getRawDate( int index ) throws SQLException
	{
		byte[] r = row[ index - 1 ];
		if ( wasNull = (r == null) )
			return null;
		int val = ( r[ 3 ] << 8 | ( r[ 2 ] & 0xff ) );
		if ( wasNull = (val == 0) )
			return null;
		StringBuilder res = new StringBuilder().append( val ).append( '-' );
		val = r[ 1 ]; // month
		if ( val < 10 )
			res.append( '0' );
		res.append( val ).append( '-' );
		val = r[ 0 ]; // day
		if ( val < 10 )
			res.append( '0' );
		return res.append( val ).toString();
	}

	@Override
	public int getInt( int index ) throws SQLException
	{
		int res = -1;
		byte[] r = row[ index - 1 ];
		if ( r != null )
			res = ( (r[3] << 24) |
					( (r[2] & 0xff) << 16) |
					  ( (r[1] & 0xff) << 8) |
					    ( (r[0] & 0xff) ) );
		wasNull = (res == -1);
		return res;
	}

	@Override
	public String getString( int index ) throws SQLException
	{
		byte[] r = row[ index - 1 ];
		wasNull = ( r == null || r.length <= 2 );
		return wasNull ? null : new String( r, 2, r.length - 2 );
	}

	@Override
	public byte[] getBytes( int index ) throws SQLException
	{
		byte[] r = row[ index - 1 ];
		wasNull = ( r == null || r.length == 0 );
		if ( wasNull )
			return null;
		byte[] res = new byte[ r.length - 2 ];
		System.arraycopy( r, 2, res, 0, res.length );
		return res;
	}

	@Override
	public Blob getBlob( int columnIndex ) throws SQLException
	{
		byte[] r = row[ columnIndex - 1 ];
		wasNull	= ( r == null || r.length == 0 );
		if ( wasNull )
			return null;
		BlobId id = new BlobId();
		System.arraycopy( r, 0, id.id, 0, BlobId.BLOB_HASH_SIZE + 4 + 4 );
		return new org.inria.jdbc.Blob( client, id );
	}

	@Override
	public Date getDate( String columnLabel ) throws SQLException { return getDate(findColumn(columnLabel)); }
	@Override
	public int getInt( String columnLabel ) throws SQLException { return getInt(findColumn(columnLabel)); }
	@Override
	public String getString( String columnLabel ) throws SQLException { return getString(findColumn(columnLabel)); }
	@Override
	public byte[] getBytes( String columnLabel ) throws SQLException { return getBytes(findColumn(columnLabel)); }
	@Override
	public Blob getBlob( String columnLabel ) throws SQLException { return getBlob( findColumn( columnLabel ) ); }
}
